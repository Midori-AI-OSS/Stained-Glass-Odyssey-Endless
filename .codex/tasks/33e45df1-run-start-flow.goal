# Goal: Operationalize Run Configuration Modifiers

## Summary
The run startup experience now ships as a multi-step wizard that fetches `/run/config` metadata, guides party selection, and posts the full `run_type` plus modifier payload back to the backend while emitting telemetry for each step.【F:frontend/src/lib/components/RunChooser.svelte†L1-L462】【F:frontend/tests/run-wizard-flow.vitest.js†L1-L120】 The UI API normalizes these selections before calling `start_run`, and the service layer validates the configuration, persists a snapshot on the run record, and logs tracking events that include reward bonuses and the chosen metadata version.【F:frontend/src/lib/systems/uiApi.js†L50-L128】【F:backend/services/run_service.py†L171-L333】【F:backend/tracking/service.py†L102-L132】 Run configuration metadata enumerates rich modifier semantics, but in play the only consumer is the boss-rush shortcut in the map generator; foe scaling, shop pricing, and encounter odds still rely on legacy pressure heuristics.【F:backend/services/run_configuration.py†L132-L520】【F:backend/autofighter/mapgen.py†L145-L154】【F:backend/autofighter/rooms/foe_factory.py†L32-L200】【F:backend/autofighter/rooms/shop.py†L19-L178】

## Current State Observations
- `RunChooser` replaces the legacy single-click overlay with a resume gate, party builder, run type chooser, modifier configuration, and confirmation screen, persisting defaults to local storage and logging impressions/actions via `log_menu_action`.【F:frontend/src/lib/components/RunChooser.svelte†L13-L414】
- UI tests cover the wizard flow, ensuring metadata errors surface, modifier changes persist, and telemetry calls fire as expected.【F:frontend/tests/run-wizard-flow.vitest.js†L33-L117】
- `start_run` stores a configuration snapshot (including client metadata version), scales party EXP/RDR multipliers, writes the snapshot into the save data, and forwards the enriched payload to telemetry and tracking tables.【F:backend/services/run_service.py†L171-L333】【F:backend/tracking/service.py†L102-L132】
- Metadata helpers define per-modifier effects, diminishing returns, and reward formulas, yet no runtime systems besides boss-rush detection read those values; `MapGenerator`, `FoeFactory`, and shop pricing continue to use hard-coded pressure coefficients.【F:backend/services/run_configuration.py†L132-L520】【F:backend/autofighter/mapgen.py†L145-L154】【F:backend/autofighter/rooms/foe_factory.py†L32-L200】【F:backend/autofighter/rooms/shop.py†L19-L178】

## Desired Outcomes
1. **Metadata consumption & UX polish**
   - Audit the wizard to ensure every run modifier exposes its tooltip, reward preview, and stacking rules, filling in any missing copy and aligning layout with the metadata schema (categories, icons, danger tags).【F:frontend/src/lib/components/RunChooser.svelte†L13-L414】【F:backend/services/run_configuration.py†L340-L520】 Add explicit tooltip copy that calls out uncapped modifier stacking so players understand the potential for extreme configurations at selection time.
   - Stretch the `Configure Modifiers` step container to occupy the full menu panel height so scroll bars disappear unless content actually overflows, keeping the call-to-action anchored consistently with other wizard steps.【F:frontend/src/lib/components/RunChooser.svelte†L13-L414】
   - Cache the fetched metadata per client session so returning to the wizard avoids redundant network calls while still handling version mismatches gracefully via the stored metadata hash.【F:frontend/src/lib/systems/uiApi.js†L50-L128】【F:backend/routes/ui.py†L520-L590】
   - Persist recently used modifier presets locally and resurface them as quick-start options to close the UX gap between “resume last run” and fresh wizard flows, now that direct run resume is unsupported.【F:frontend/src/lib/components/RunChooser.svelte†L416-L439】
2. **Gameplay integration of run modifiers**
   - Thread the stored `run_config` snapshot through map generation and encounter assembly so modifier stacks influence spawn counts, elite/prime/glitched odds, and foe stat scaling instead of relying solely on static pressure math.【F:backend/autofighter/mapgen.py†L145-L154】【F:backend/autofighter/rooms/foe_factory.py†L32-L200】
   - Apply foe- and player-focused modifiers when instantiating combatants (HP, mitigation, vitality, action speed) and when calculating player stat penalties/bonuses, leveraging the effect data already exposed in `RunConfigurationSelection`.【F:backend/services/run_configuration.py†L132-L520】【F:backend/services/run_service.py†L171-L333】
   - Extend shop generation and pricing logic to respect modifier-driven shop multipliers or tax rules instead of the fixed `1.26^pressure` curve, ensuring preview math in the wizard matches in-game economy behavior.【F:backend/autofighter/rooms/shop.py†L19-L178】【F:frontend/src/lib/components/RunChooser.svelte†L416-L439】
3. **Analytics and surfacing follow-through**
   - Expose the persisted configuration snapshot during active runs (e.g., map HUD, pause overlays) so players can verify modifiers mid-run, mirroring the battle review panel’s configuration summary.【F:frontend/src/lib/components/battle-review/BattleReviewMenu.svelte†L285-L314】【F:frontend/src/lib/components/OverlayHost.svelte†L285-L294】
   - Expand tracking queries or dashboards to aggregate modifier usage and reward outcomes now that `run_configurations` captures run type, modifier stacks, and reward multipliers for every session.【F:backend/tracking/service.py†L102-L132】
4. **Documentation & validation**
   - Update `.codex/implementation/game-workflow.md` and related onboarding docs to describe how modifiers affect gameplay systems once integrated.【F:.codex/implementation/game-workflow.md†L15-L48】
   - Add backend unit coverage for the new modifier hooks (e.g., foe factory scaling, shop pricing) and extend frontend tests if additional UI surfaces are introduced for mid-run visibility.【F:frontend/tests/run-wizard-flow.vitest.js†L33-L117】【F:backend/tests/test_run_configuration_service.py†L10-L64】

## Open Questions / Follow-ups
- How should the UX communicate extreme modifier combinations so players understand they are intentionally uncapped while still surfacing encounter difficulty expectations?
- What retention strategy should telemetry adopt for long-term modifier analytics (granularity, retention window, anonymization) now that richer payloads ship with each run start?
